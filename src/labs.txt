----------------------------------------------------------------------
h1. Setup

h2. Goals

* To setup git and ruby so that it is ready for work.

h2. Setup Name and Email

p. If you have never used git before, you need to do some setup first.
Run the following commands so that git knows your name and email.  If
you have git already setup, you can skip down to the line ending
section.

execute:
git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

h2. Setup Line Ending Preferences

Also, for Unix/Mac users:

execute:
git config --global core.autocrlf input
git config --global core.safecrlf true

And for Windows users:

execute:
git config --global core.autocrlf true
git config --global core.safecrlf true

h2. Setup the Default Branch Name

p. When you initialize a new project using git it creates an initial branch
with a default name of @master@. You'll learn more about these branches in
future labs, but right now we'll override that default name to be @main@
instead. This align's with GitHub's current defaults and will make it easier to
interact with your future projects there. See GitHub's
"article":https://github.com/github/renaming/ for more information.

Execute:
git config --global init.defaultBranch main

h2. Setup Ruby

p. For this tutorial you need a working Ruby interpreter. If you havenÂ´t one
installed yet, it is time to set it up now:

"https://www.ruby-lang.org/en/installation/":https://www.ruby-lang.org/en/installation/

----------------------------------------------------------------------
h1. More Setup

h2. Goals

* Get the tutorial materials setup and ready to run.

h2. Get the Tutorial package

* Download from: "git_tutorial.zip":git_tutorial.zip

h2. Unzip the tutorial

p. The tutorial package should have a main directory "git_tutorial"
with three sub-directories:

* html -- These html files.  Point your browser to html/index.html
* work -- An empty working directory.  Create your repos in here.
* repos -- Prepackaged Git repositories so you can jump into the tutorial at any point.  If you get stuck, just copy the desired lab into your working directory.

----------------------------------------------------------------------
h1. Create a Project

h2. Goals

* Learn how to create a git repository from scratch.

h2. Create a "Hello, World" program

p. Starting in the empty working directory, create an empty directory
named "hello", then create a file named @hello.rb@ with the contents
below.

Execute:
mkdir hello
cd hello

File: hello.rb
puts "Hello, World"
EOF

h2. Create the Repository

p. You now have a directory with a single file.  To create a git
repository from that directory, run the git init command.

Execute:
git init
=init
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"

Output:
=init
EOF

h2. Add the program to the repository

Now let's add the "Hello, World" program to the repository.

Execute:
git add hello.rb
=add
git commit -m "First Commit"
=commit

p. You should see ...

Output:
=add
=commit
EOF

----------------------------------------------------------------------
h1. Checking Status

h2. Goals

* Learn how to check the status of the repository

h2. Check the status of the repository

p. Use the @git status@ command to check the current status of the
repository.

Execute:
git status
=status

p. You should see

Output:
=status
EOF

p. The status command reports that there is nothing to commit.  This
means that the repository has all the current state of the working
directory.  There are no outstanding changes to record.

p. We will use the @git status@ command to continue to monitor the
state between the repository and the working directory.

h2. Check for any changes to the repository

p. Use the @git diff@ command to view any pending changes to be committed.

Execute:
git diff
=diff

p. You should see no output because there are no changes yet. Not to worry,
you'll be adding some changes in the next lesson.

Output:
=diff
EOF

----------------------------------------------------------------------
h1. Making Changes

h2. Goals

* Learn how to monitor the state of the working directory

h2. Change the "Hello, World" program.

p. It's time to change our hello program to take an argument from the
command line.  Change the file to be:

File: hello.rb
puts "Hello, #{ARGV.first}!"
EOF

h2. Check the status

p. Now check the status of the working directory.

Execute:
!git status
=status

p. You should see ...

Output:
=status
EOF

p. The first thing to notice is that git knows that the @hello.rb@
file has been modified, but git has not yet been notified of these
changes.

p. Also notice that the status message gives you hints about what you
need to do next.  If you want to add these changes to the repository,
then use the @git add@ command.  Otherwise the @git checkout@ command
can be used to discard the changes.

p. Now check what the changes are.

Execute:
git diff
=diff

p. You'll see that there is a line starting with a '-' character which
indicates a line that was removed. There is also a line starting with a '+'
character which indicates a line that was added. When you change a line of
text, git treats it as a removal and an addition.

Output:
=diff
EOF

h2. Up Next

p. Let's stage the change.

----------------------------------------------------------------------
h1. Staging Changes

h2. Goals

* Learn how to stage changes for later commits

h2. Add Changes

p. Now tell git to stage the changes.  Check the status

Execute:
git add hello.rb
=add
git status
=status

p. You should see ...

Output:
=add
=status
EOF

p. The change to the @hello.rb@ file has been staged.  This means that
git now knows about the change, but the change hasn't been
_permanently_ recorded in the repository yet.  The next commit
operation will include the staged changes.

p. If you decide you _don't_ want to commit that change after all, the
status command reminds you that the @git restore@ command can be used to
unstage that change.

----------------------------------------------------------------------
h1. Staging and Committing

p. A separate staging step in git is in line with the philosophy of
getting out of the way until you need to deal with source control.
You can continue to make changes to your working directory, and then
at the point you want to interact with source control, git allows you
to record your changes in small commits that record exactly what you
did.

p. For example, suppose you edited three files (@a.rb@, @b.rb@, and
@c.rb@).  Now you want to commit all the changes, but you want the
changes in @a.rb@ and @b.rb@ to be a single commit, while the changes
to @c.rb@ are not logically related to the first two files and should
be a separate commit.

p. You could do the following:

pre(instructions).
git add a.rb
git add b.rb
git commit -m "Changes for a and b"

pre(instructions).
git add c.rb
git commit -m "Unrelated change to c"

p. By separating staging and committing, you have the ability to
easily fine tune what goes into each commit.

----------------------------------------------------------------------
h1. Committing Changes

h2. Goals

* Learn how to commit changes to the repository

h2. Commit the change

p. Ok, enough about staging.  Let's commit what we have staged to the
repository.

p. When you used @git commit@ previously to commit the initial version
of the @hello.rb@ file to the repository, you included the @-m@ flag
that gave a comment on the command line.  The commit command will
allow you to interactively edit a comment for the commit.  Let's try
that now.

p. If you omit the @-m@ flag from the command line, git will pop you
into the editor of your choice.  The editor is chosen from the
following list (in priority order):

* GIT_EDITOR environment variable
* core.editor configuration setting
* VISUAL environment variable
* EDITOR environment variable

p. I have the EDITOR variable set to @emacsclient@.

p. So commit now and check the status.

Execute:
-git commit
+git commit -m "Using ARGV"

p. You should see the following in your editor:

Output:
|
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch main
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   hello.rb
#
EOF

p. On the first line, enter the comment: "Using ARGV".  Save the file
and exit the editor.  You should see ...

Output:
git commit
Waiting for Emacs...
[main 569aa96] Using ARGV
 1 files changed, 1 insertions(+), 1 deletions(-)
EOF

p. The "Waiting for Emacs..." line comes from the @emacsclient@
program which sends the file to a running emacs program and waits for
the file to be closed.  The rest of the output is the standard commit
messages.

h2. Check the status

p. Let's make sure the commit looks okay.

Execute:
git show
=show

You should see something similar to this with different timestamps and a
different author.

Output:
=show
EOF

p. Finally let's check the status again.

Execute:
!git status
=status

You should see ...

Output:
=status
EOF

p. The working directory is clean and ready for you to continue.

----------------------------------------------------------------------
h1. Changes, not Files

h2. Goals

* Learn that git works with changes, not files.

p. Most source control systems work with files.  You add a file to
source control and the system will track changes to the file from that
point on.

p. Git focuses on the changes to a file rather than the file itself.
When you say @git add file@, you are not telling git to add the file
to the repository.  Rather you are saying that git should make note of
the current state of that file to be committed later.

p. We will attempt to explore that difference in this lab.

h2. First Change: Allow a default name

p. Change the "Hello, World" program to have a default value if a
command line argument is not supplied.

File: hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Add this Change

p. Now add this change to the git's staging area.

Execute:
git add hello.rb

h2. Second change: Add a comment

p. Now add a comment to the "Hello, World" program.

File: hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Check the current status

Execute:
!git status
=status

p. You should see ...

Output:
=status
EOF

p. Notice how @hello.rb@ is listed twice in the status.  The first
change (adding a default) is staged and is ready to be committed.  The
second change (adding a comment) is unstaged.  If you were to commit
right now, the comment would not be saved in the repository.

p. Let's try that.

h2. Committing

p. Commit the staged change (the default value), and then recheck the
status.

Execute:
git commit -m "Added a default value"
=commit
git status
=status2

p. You should see ...

Output:
=commit
=status2
EOF

p. The status command is telling you that @hello.rb@ has unrecorded changes,
but is no longer in the staging area.

h2. Add the Second Change

p. Now add the second change to staging area, then run git status.

Execute:
git add .
!git status
=status3

p(note). *Note:* We used the current directory ('.') as the
file to add.  This is a really convenient shortcut for adding in all
the changes to the files in the current directory and below.  But
since it adds everything, it is a _really_ good idea to check the status
before doing an <tt>add .</tt>, just to make sure you don't add any
file that is not intended.

p(note). I wanted you to see the "add ." trick, but we will
continue to add explicit files in the rest of this tutorial just to be
safe.

p. You should see ...

Output:
=status3
EOF

p. Now the second change has been staged and is ready to commit.

h2. Commit the Second Change

Execute:
git commit -m "Added a comment"

----------------------------------------------------------------------
h1. Working with Changes Directly

h2. Goals

* Now that you've learned how git works with changes to files rather than files themselves, you will learn how to manipulate changes before staging them.

p. Git provides rich functionality to choose precisely what changes you want to
stage. This includes both choosing individual lines to stage as well as editing
the changes before they are staged without changing the existing file. These
capabilities allow you to make and commit secondary changes while working on a
task with minimal distractions.

h2. First Change: Allow Any Number of Names

p. Change the "Hello, World" program to allow users to input any number of names.

File: hello.rb
name = ARGV || ["World"]

puts "Hello, #{name.join(" ")}!"
EOF

h2. Add and Commit the Change

p. Now you'll add the change using @git add --patch@. This will present you
with an interactive interface to select "hunks" which are sets of changes. For
now, you'll have one hunk. Press the 'y' key to select it for staging. You can
press the '?' key to get help about the other options.

Execute:
-git add --patch
+yes | git add --patch
=addpatch1

Execute:
git commit -m "Can specify multiple names"
=addpatch2

p(note). *Note:* I used a utility called @yes@ to simulate pressing the 'y' key
when the @git add --patch@ command prompted me for it. I recommend you don't do
this and instead enter your input manually.

Output:
$ git add --patch
=addpatch1

=addpatch2
EOF

h2. Second Change: Add Some More Output

p. Change the "Hello, World" program to print out the number of names a user entered.

File: hello.rb
name = ARGV || ["World"]

puts "Hello, #{name.join(" ")}!"
puts "You have #{name.length} names!"
EOF

h2. Third Change: Rename the @name@ Variable

p. The @name@ variable is indicating it's singular when it's actually plural.
Change its name to match its usage.

File: hello.rb
names = ARGV || ["World"]

puts "Hello, #{names.join(" ")}!"
puts "You have #{names.length} names!"
EOF

h2. Add The Changes

p. Now you've made two changes which should be committed as two commits.
Instead of undoing one of the changes, committing it, and redoing it you'll use
@git add --patch@ to let you do it directly. Run the following command and press
the 'e' key when prompted.

Execute:
-git add --patch
+tail -n1 hello.rb > lastline
+echo -e ":\$d\\n:x" | vim -E -s hello.rb
+git add hello.rb
+cat lastline >> hello.rb
+rm lastline

p. You'll see the following open up in your editor. It is a description of the
changes git will stage when the file is saved and closed. Editing this file
will change exactly what is staged.

Output:
# Manual hunk edit mode -- see bottom for a quick guide.
@@ -1,3 +1,4 @@
-name = ARGV || ["World"]
+names = ARGV || ["World"]

-puts "Hello, #{name.join(" ")}!"
+puts "Hello, #{names.join(" ")}!"
+puts "You have #{names.length} names!"
# ---
# To remove '-' lines, make them ' ' lines (context).
# To remove '+' lines, delete them.
# Lines starting with # will be removed.
#
# If the patch applies cleanly, the edited hunk will immediately be
# marked for staging.
# If it does not apply cleanly, you will be given an opportunity to
# edit again.  If all lines of the hunk are removed, then the edit is
# aborted and the hunk is left unchanged.
EOF

p. Let's do the variable rename first. Edit the file so it matches the example
below. I just removed the last line starting with a '+'.

Output:
# Manual hunk edit mode -- see bottom for a quick guide.
@@ -1,3 +1,4 @@
-name = ARGV || ["World"]
+names = ARGV || ["World"]

-puts "Hello, #{name.join(" ")}!"
+puts "Hello, #{names.join(" ")}!"
# ---
# To remove '-' lines, make them ' ' lines (context).
# To remove '+' lines, delete them.
# Lines starting with # will be removed.
#
# If the patch applies cleanly, the edited hunk will immediately be
# marked for staging.
# If it does not apply cleanly, you will be given an opportunity to
# edit again.  If all lines of the hunk are removed, then the edit is
# aborted and the hunk is left unchanged.
EOF

p. Save and exit, then let's check that we did everything correctly.

Execute:
git diff --staged
=diff1

p. You should see output like below

p(note). *Note:* the @--staged@ option to @git diff@ will only show your
currently staged changes.

Output:
=diff1
EOF

p. Finally let's commit the change.

Execute:
git commit -m "Rename variable to match its usage"
=addpatch3

Output:
=addpatch3
EOF

p. Now you'll add the new output. This one isn't necessary to edit, so you can
just press the 'y' key to add it.

Execute:
-git add --patch
+yes | git add --patch
=addpatch4

Execute:
git commit -m "Tell user how many names they have"
=addpatch5

Output:
$ git add --patch
=addpatch4

=addpatch5
EOF

h2. Wrapping Up

p. In this lab you learned how to interact directly with the changes to be
staged before they are staged. You simply staged some lines independently of
others, but you could also have modified the content of the lines as well. Note
that while the interface through git can be somewhat cumbersome there are
several tools that integrate with your editor to do this for you. "Here is an
example of one for
VSCode":https://marketplace.visualstudio.com/items?itemName=kahole.magit

----------------------------------------------------------------------
h1. History

h2. Goals

* Learn how to view the history of the project.

p. Getting a listing of what changes have been made is the function of
the @git log@ command.

Execute:
git log
=log

p. You should see ...

Output:
=log
EOF

p. Here is a list of all four commits that we have made to the
repository so far.

h2. One Line Histories

p. You have a great deal of control over exactly what the @log@ command
displays.  I like the one line format:

Execute:
git log --pretty=oneline
=oneline

p. You should see ...

Output:
=oneline
EOF

h2. Controlling Which Entries are Displayed

p. There are a lot of options for selecting which entries are
displayed in the log.  Play around with the following options:

pre(instructions).
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>
git log --pretty=oneline --all
git log --patch
git log -S "Hello"

p. See man git-log for all the details.

h2. Getting Fancy

p. Here's what I use to review the changes made in the last week.
I'll add @--author=jim@ if I only want to see changes I made.

pre(instructions).
git log --all --pretty=format:'%h %cd %s (%an)' --since='7 days ago'

h2. The Ultimate Log Format

p. Over time, I've decided that I like the following log format for
most of my work.

Execute:
git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
=ultimate

It looks like this:

Output:
=ultimate
EOF

p. Let's look at it in detail:

* @--pretty="..."@ defines the format of the output.
* @%h@ is the abbreviated hash of the commit
* @%d@ are any decorations on that commit (e.g. branch heads or tags)
* @%ad@ is the author date
* @%s@ is the comment
* @%an@ is the author name
* @--graph@ informs git to display the commit tree in an ASCII graph layout
* @--date=short@ keeps the date format nice and short

p. This is a lot to type every time you want to see the log.
Fortunately we will learn about git aliases in the next lab.

h2. Other Tools

p. Both <code>gitx</code> (for Macs) and <code>gitk</code> (any
platform) are useful in exploring log history.

----------------------------------------------------------------------
h1. Aliases

h2. Goals

* Learn how to setup aliases and shortcuts for git commands

h2. Common Aliases

p. @git status@, @git add@, @git commit@, and @git checkout@ are such
common commands that it is useful to have abbreviations for them.

p. Add the following to the .gitconfig file in your $HOME directory.

file: .gitconfig
[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
  type = cat-file -t
  dump = cat-file -p
EOF

p. We've covered the commit and status commands already.  And we just
covered the @log@ command in the previous lab. The @checkout@ command
will be coming up soon.

p. With these aliases defined in the @.gitconfig@ file you can type
@git co@ wherever you used to have to type @git checkout@.  Likewise
with @git st@ for @git status@ and @git ci@ for @git commit@.  And
best of all, @git hist@ will allow you to avoid the really long @log@
command.

p. Go ahead and give the new commands a try.

h2. Define the @hist@ alias in your @.gitconfig@ file

p. For the most part, I will continue to type out the full command in
these instructions.  The only exception is that I will use the @hist@
alias defined above anytime we need to see the git log output.  Make
sure you have a @hist@ alias setup in your @.gitconfig@ file before
continuing if you wish to follow along.

h2. @Type@ and @Dump@

p. We've added a few aliases for commands we haven't covered yet. The
@git branch@ command will be coming up soon.  And the @git cat-file@
command is useful for exploring git, which we will see in a little
while.

h2. Shell Aliases (Optional)

p(note). *Note:* This section is for folks running a posix-like shell.
Windows users and other non-posix shell users can feel free to skip to
the next lab.

p. If your shell supports aliases or shortcuts, then you can add
aliases at that level too.  Here are the ones I use:

file: .profile
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias gco='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '
EOF

p. The @gco@ abbreviation for @git checkout@ is particularly nice.  It
allows me to type:

pre(instructions). gco <branch>

p. to checkout a particular branch.

p. And yes, I do mistype @git@ as @get@ or @got@ often enough to
create aliases for them.

----------------------------------------------------------------------
h1. Getting Old Versions

h2. Goals

* Learn how to checkout any previous snapshot into the working directory.

p. Going back in history is very easy.  The checkout command will copy
any snapshot from the repository to the working directory.

h2. Get the hashes for previous versions

Execute:
git hist
=log

p(note). *Note:* You did remember to define @hist@ in your
@.gitconfig@ file, right?  If not, review the lab on aliases.

Output:
=log
EOF

p. Examine the log output and find the hash for the first commit.  It
should be the last line of the @git hist@ output.  Use that hash code
(the first 7 characters are enough) in the command below to see what that
commit changed.

Set: hash=hash_for("First Commit")
Execute:
git show <hash>
=show

Output:
=show
EOF

p. Now let's checkout the commit and then check the contents of the hello.rb
file.

Set: hash=hash_for("First Commit")
Execute:
git checkout <hash>
=checkout
cat hello.rb
=cat

p(note). *Note:* The commands given here are Unix commands and
work on both Mac and Linux boxes.  Unfortunately, Windows users will
have to translate to their native commands.

p(note). *Note:* Many commands depend on the hash values in the
repository.  Since your hash values will vary from mine, whenever you
see something like &lt;hash&gt; or &lt;treehash&gt; in the command,
substitute in the proper hash value for your repository.

p. You should see ...

Output:
=checkout
=cat
EOF

p. The output of the @checkout@ command explains the situation pretty
well.  Older versions of git will complain about not being on a local
branch.  In any case, don't worry about that for now.

p. Notice the contents of the hello.rb file are the original contents.

h2. Return the latest version in the main branch

Execute:
git checkout main
=checkout2
cat hello.rb
=cat2

p. You should see ...

Output:
=checkout2
=cat2
EOF

p. 'main' is the name of the default branch.  By checking out a branch
by name, you go to the latest version of that branch.

----------------------------------------------------------------------
h1. Tagging versions

h2. Goals

* Learn how to tag commits with names for future reference

p. Let's call the current version of the hello program version 1 (v1).

h2. Tagging version 1

Execute:
git tag v1
=tag

p. Now you can refer to the current version of the program as v1.

h2. Tagging Previous Versions

p. Let's tag the version immediately prior to the current version
v1-beta.  First we need to checkout the previous version.  Rather than
look up the hash, we will use the @^@ notation to indicate "the parent
of v1".

p(note). If the @v1@^ notation gives you any trouble, you can also try
@v1~1@, which will reference the same version.  This notation means
"the first ancestor of v1".

Execute:
git checkout v1^
=checkout
cat hello.rb
=cat

Output:
=checkout
=cat
EOF

p. See, this is the version with the default value _before_ we added
the comment.  Let's make this v1-beta.

Execute:
git tag v1-beta

h2. Checking Out by Tag Name

p. Now try going back and forth between the two tagged versions.

Execute:
git checkout v1
=cov1
git checkout v1-beta
=cov1beta

Output:
=cov1
=cov1beta
EOF

h2. Viewing Tags using the @tag@ command

p. You can see what tags are available using the @git tag@ command.

Execute:
git tag
=tag2

Output:
=tag2
EOF

h2. Viewing Tags in the Logs

p. You can also check for tags in the log.

Execute:
git hist main --all
=hist

Output:
=hist
EOF

p. You can see both tags (@v1@ and @v1-beta@) listed in the log
output, along with the branch name (@main@).  Also @HEAD@ shows you
the currently checked out commit (which is @v1-beta@ at the moment).

----------------------------------------------------------------------
h1. Undoing Local Changes (before staging)

h2. Goals

* Learn how to revert changes in the working directory

h2. Checkout Main

p. Make sure you are on the latest commit in main before proceeding.

Execute:
git checkout main

h2. Change hello.rb

p. Sometimes you have modified a file in your local working directory
and you wish to just revert to what has already been committed.  The
checkout command will handle that.

Change hello.rb to have a bad comment.

File: hello.rb
# This is a bad comment.  We want to revert it.
names = ARGV || ["World"]

puts "Hello, #{names.join(" ")}!"
puts "You have #{names.length} names!"
EOF

h2. Check the Status

p. First, check the status of the working directory.

Execute:
!git status
=status

Output:
=status
EOF

p. We see that the @hello.rb@ file has been modified, but hasn't been
staged yet.

h2. Revert the changes in the working directory

p. Use the @restore@ command to checkout the repository's version of
the @hello.rb@ file.

Execute:
git restore hello.rb
=restore
!git status
=status2
cat hello.rb
=cat

Output:
=restore
=status2
=cat
EOF

p. The status command shows us that there are no outstanding changes
in the working directory.  And the "bad comment" is no longer part of
the file contents.

----------------------------------------------------------------------
h1. Undoing Staged Changes (before committing)

h2. Goals

* Learn how to revert changes that have been staged

h2. Change the file and stage the change

p. Modify the @hello.rb@ file to have a bad comment

File: hello.rb
# This is an unwanted but staged comment
names = ARGV || ["World"]

puts "Hello, #{names.join(" ")}!"
puts "You have #{names.length} names!"
EOF

p. And then go ahead and stage it.

Execute:
git add hello.rb

h2. Check the Status

p. Check the status of your unwanted change.

Execute:
git status
=status

Output:
=status
EOF

p. The status output shows that the change has been staged and is
ready to be committed.

h2. Restore the Staged File

p. The @restore@ command from the previous lab also works to unstage changes to
a file.

Execute:
git restore --staged hello.rb
=restore

Output:
=restore
EOF

p. The @restore@ command only unstaged the file. We can repeat the command to
remove the unwanted changes from the working directory.

h2. Restore the Committed Version

Execute:
git restore hello.rb
git status
=status2

Output:
=status2
EOF

p. And our working directory is clean once again.

----------------------------------------------------------------------
h1. Undoing Committed Changes

h2. Goals

* Learn how to revert changes that have been committed to a local repository.

h2. Undoing Commits

p. Sometimes you realized that a change that you have already
committed was not correct and you wish to undo that commit.  There are
several ways of handling that issue, and the way we are going to use
in this lab is always safe.

p. Essentially we will undo the commit by creating a new commit that
reverses the unwanted changes.

h2. Change the file and commit it.

p. Change the @hello.rb@ file to the following.

File: hello.rb
# This is an unwanted but committed change
names = ARGV || ["World"]

puts "Hello, #{names.join(" ")}!"
puts "You have #{names.length} names!"
EOF

Execute:
git add hello.rb
git commit -m "Oops, we didn't want this commit"

h2. Create a Reverting Commit

p. To undo a committed change, we need to generate a commit that
removes the changes introduced by our unwanted commit.

Execute:
-git revert HEAD
+git revert HEAD --no-edit
=revert

p. This will pop you into the editor.  You can edit the default commit
message or leave it as is.  Save and close the file. You should see ...

Output:
=revert
EOF

p. Since we were undoing the very last commit we made, we were able to
use @HEAD@ as the argument to revert.  We can revert any arbitrary
commit earlier in history by simply specifying its hash value.

p(note). *Note:* The @--no-edit@ in the output can be ignored.
It was necessary to generate the output without opening the editor.

h2. Check the log

p. Checking the log shows both the unwanted and the reverting commits
in our repository.

Execute:
git hist
=hist

Output:
=hist
EOF

p. This technique will work with any commit (although you may have to
resolve conflicts).  It is safe to use even on branches that are
publicly shared on remote repositories.

h2. Up Next

p. Next, let's look at a technique that can be used to remove the most
recent commits from the repository history.

----------------------------------------------------------------------
h1. Removing Commits from a Branch

h2. Goals

* Learn how to remove the most recent commits from a branch

p. The @revert@ command of the previous section is a powerful command
that lets us undo the effects of any commit in the repository.
However, both the original commit and the "undoing" commit are visible
in the branch history (using the @git log@ command).

p. Often we make a commit and immediately realize that it was a
mistake.  It would be nice to have a "take back" command that would
allow us to pretend that the incorrect commit never happened.  The
"take back" command would even prevent the bad commit from showing up
the @git log@ history.  It would be as if the bad commit never
happened.

h2. The @reset@ command

p. We've already seen the @reset@ command and have used it to set the
staging area to be consistent with a given commit (we used the HEAD
commit in our previous lab).

p. When given a commit reference (i.e. a hash, branch or tag name),
the @reset@ command will ...

# Rewrite the current branch to point to the specified commit
# Optionally reset the staging area to match the specified commit
# Optionally reset the working directory to match the specified commit

h2. Check Our History

p. Let's do a quick check of our commit history.

Execute:
git hist
=hist

Output:
=hist
EOF

p. We see that we have an "Oops" commit and a "Revert Oops" commit as
the last two commits made in this branch.  Let's remove them using
reset.

h2. First, Mark this Branch

p. But before we remove the commits, let's mark the latest commit with
a tag so we can find it again.

Execute:
git tag oops

h2. Reset to Before Oops

p. Looking at the log history (above), we see that the commit tagged
'v1' is the commit right before the bad commit.  Let's reset the
branch to that point.  Since that branch is tagged, we can use the tag
name in the reset command (if it wasn't tagged, we could just use the
hash value).

Execute:
git reset --hard v1
=reset
git hist
=hist2

Output:
=reset
=hist2
EOF

p. Our main branch now points to the v1 commit and the Oops commit
and the Revert Oops commit are no longer in the branch.  The @--hard@
parameter indicates that the working directory should be updated to be
consistent with the new branch head.

h2. Nothing is Ever Lost

p. But what happened to the bad commits?  It turns out that the
commits are still in the repository.  In fact, we can still reference
them.  Remember that at the beginning of this lab we tagged the
reverting commit with the tag "oops".  Let's look at _all_ the commits.

Execute:
git hist --all
=hist3

Output:
=hist3
EOF

p. Here we see that the bad commits haven't disappeared.  They are
still in the repository.  It's just that they are no longer listed in
the main branch.  If we hadn't tagged them, they would still be in
the repository, but there would be no way to reference them other than
using their hash names.  Commits that are unreferenced remain in the
repository until the system runs the garbage collection software.

h2. Dangers of Reset

p. Resets on local branches are generally safe.  Any "accidents" can
usually be recovered from by just resetting again with the desired
commit.

p. However, if the branch is shared on remote repositories, resetting
can confuse other users sharing the branch.

----------------------------------------------------------------------
h1. Remove the oops tag

h2. Goals

* Remove the oops tag (housekeeping)

h2. Removing tag oops

p. The oops tag has served its purpose.  Let's remove it and allow the
commits it referenced to be garbage collected.

Execute:
git tag -d oops
=tag
git hist --all
=hist

Output:
=tag
=hist
EOF

p. The oops tag is no longer listed in the repository.

----------------------------------------------------------------------
h1. Amending Commits

h2. Goals

* Learn how to amend an existing commit

h2. Change the program then commit

p. Add an author comment to the program.

File: hello.rb
# Default is World
# Author: Jim Weirich
names = ARGV || ["World"]

puts "Hello, #{names.join(" ")}!"
puts "You have #{names.length} names!"
EOF

Execute:
git add hello.rb
git commit -m "Add an author comment"

h2. Oops, Should have an Email

p. After you make the commit, you realize that any good author comment
should have an email included.  Update the hello program to include an
email.

File: hello.rb
# Default is World
# Author: Jim Weirich (jim@somewhere.com)
names = ARGV || ["World"]

puts "Hello, #{names.join(" ")}!"
puts "You have #{names.length} names!"
EOF

h2. Amend the Previous Commit

p. We really don't want a separate commit for just the email.  Let's
amend the previous commit to include the email change.

Execute:
git add hello.rb
=add
git commit --amend -m "Add an author/email comment"
=commit

Output:
=add
=commit
EOF


h2. Review the History

Execute:
git hist
=hist

Output:
=hist
EOF

p. We can see the original "author" commit is now gone, and it is
replaced by the "author/email" commit.  You can achieve the same
effect by resetting the branch back one commit and then recommitting
the new changes.

----------------------------------------------------------------------
h1. Moving Files

h2. Goals

* Learn how to move a file within a repository.

h2. Move the hello.rb file into a lib directory.

p. We are now going to build up the structure of our little
repository.  Let's move the program into a lib directory.

Execute:
mkdir lib
=mkdir
git mv hello.rb lib
=move
!git status
=status

Output:
=mkdir
=move
=status
EOF

p. By using git to do the move, we inform git of 2 things

# That the file @hello.rb@ has been deleted.
# The file @lib/hello.rb@ has been created.

p. Both of these bits of information are immediately staged and ready
to be committed.  The git status command reports that the file has been
moved.

h2. Another way of moving files

p. One of the nice things about git is that you can forget about
source control until the point you are ready to start committing code.
What would happen if we used the operating system command to move the
file instead of the git command?

p. It turns out the following set of commands is identical to what we
just did.  It's a bit more work, but the result is the same.

p(command). We could have done:

pre(instructions). mkdir lib
mv hello.rb lib
git add lib/hello.rb
git rm hello.rb

h2. Commit the new directory

p. Let's commit this move.

Execute:
git commit -m "Moved hello.rb to lib"

----------------------------------------------------------------------
h1. More Structure

h2. Goals

* Add another file to our repository

h2. Now add a Rakefile

p. This lab assumes you have installed *rake*. Please
do that before continuing. Check for your specific Operating System.
Otherwise execute:

Execute:
gem install rake

p. Let's add a Rakefile to our repository.  The following one will do
nicely.

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  require './lib/hello'
end
EOF

p. Add and commit the change.

Execute:
git add Rakefile
git commit -m "Added a Rakefile."

p. You should be able to use Rake to run your hello program now.

Execute:
rake
=rake

Output:
=rake
EOF

----------------------------------------------------------------------
h1. Git Internals: The .git directory

h2. Goals

* Learn about the structure of the @.git@ directory

h2. The @.git@ Directory

p. Time to do some exploring.  First, from the root of your project
directory...

Execute:
ls -C .git
=lsgit

Output:
=lsgit
EOF

p. This is the magic directory where all the git "stuff" is stored.
Let's peek in the objects directory.

h2. The Object Store

Execute:
ls -C .git/objects
=lsobjs

Output:
=lsobjs
EOF

p. You should see a bunch of directories with 2 letter names.  The
directory names are the first two letters of the sha1 hash of the
object stored in git.

h2. Deeper into the Object Store

Set: dir=`ls .git/objects | head -1`.strip
Execute:
ls -C .git/objects/<dir>
=lsobjs2

Output:
=lsobjs2
EOF

p. Look in one of the two-letter directories.  You should see some
files with 38-character names.  These are the files that contain the
objects stored in git.  These files are compressed and encoded, so
looking at their contents directly won't be very helpful, but we will
take a closer look in a bit.

h2. Config File

Execute:
cat .git/config
=cat

Output:
=cat
EOF

p. This is a project-specific configuration file.  Config entries in
here will override the config entries in the @.gitconfig@ file in your
home directory, at least for this project.

h2. Branches and Tags

Execute:
ls .git/refs
=refs
ls .git/refs/heads
=refhead
ls .git/refs/tags
=reftags
cat .git/refs/tags/v1
=refv1

Output:
=refs
=refhead
=reftags
=refv1
EOF

p. You should recognize the files in the tags subdirectory.  Each file
corresponds to a tag you created with the @git tag@ command earlier.
Its content is just the hash of the commit tied to the tag.

p. The heads directory is similar, but is used for branches rather
than tags.  We only have one branch at the moment, so all you will see
is main in this directory.

h2. The HEAD File

Execute:
cat .git/HEAD
=head

Output:
=head
EOF

p. The HEAD file contains a reference to the current branch.  It
should be a reference to main at this point.

----------------------------------------------------------------------
h1. Git Internals: Working directly with Git Objects

h2. Goals

* Explore the structure of the object store
* Learn how to use the SHA1 hashes to find content in the repository

p. Now let's use some tools to probe git objects directly.

h2. Finding the Latest Commit

Execute:
git hist --max-count=1
=log

p. This should show the latest commit made in the repository.  The
SHA1 hash on your system is probably different from what is on mine,
but you should see something like this.

Output:
=log
EOF

h2. Dumping the Latest Commit

Using the SHA1 hash from the commit listed above ...

Set: hash=hash_for("Added a Rakefile")
Execute:
git cat-file -t <hash>
=type
git cat-file -p <hash>
=dump

Here's my output ...

Output:
=type
=dump
EOF

p(note). *NOTE:* If you defined the 'type' and 'dump' aliases from
the aliases lab, then you can type @git type@ and @git dump@ rather
than the longer cat-file commands (which I never remember).

p. This is the dump of the commit object that is at the head of the
main branch.  It looks a lot like the commit object from the
presentation earlier.

h2. Finding the Tree

p. We can dump the directory tree referenced in the commit.  This
should be a description of the (top level) files in our project (for
that commit).  Use the SHA1 hash from the "tree" line listed above.

Set: treehash=hash_in(var['hash'], 'tree')
Execute:
git cat-file -p <treehash>
=treedump

p. Here's what my tree looks like...

Output:
=treedump
EOF

p. Yep, I see the Rakefile and the lib directory.

h2. Dumping the lib directory

Set: libhash=hash_in(var['treehash'], 'lib')
Execute:
git cat-file -p <libhash>
=libdump

Output:
=libdump
EOF

p. There's the @hello.rb@ file.

h2. Dumping the @hello.rb@ file

Set: rbhash=hash_in(var['libhash'], 'hello')
Execute:
git cat-file -p <rbhash>
=rbdump

Output:
=rbdump
EOF

p. There you have it.  We've dumped commit objects, tree objects and
blob objects directly from the git repository.  That's all there is to
it, blobs, trees and commits.

h2. Explore On You Own

p. Explore the git repo manually on your own.  See if you can find the
original hello.rb file from the very first commit by manually
following the SHA1 hash references starting in the latest commit.

----------------------------------------------------------------------
h1. Creating a Branch

h2. Goals

* Learn how to create a local branch in a repository

p. It's time to do a major rewrite of the hello world functionality.
Since this might take awhile, you'll want to put these changes into a
separate branch to isolate them from changes in main.

h2. Create a Branch

p. Let's call our new branch 'greet'.

Execute:
git checkout -b greet
!git status

p(note). *NOTE:* @git checkout -b <branchname>@ is a shortcut for @git
branch <branchname>@ followed by a @git checkout <branchname>@.

p. Notice that the git status command reports that you are on the
'greet' branch.

h2. Changes for Greet: Add a Greeter class.

File: lib/greeter.rb
class Greeter
  def initialize(who)
    @who = who
  end
  def greet
    "Hello, #{@who}"
  end
end
EOF

Execute:
git add lib/greeter.rb
git commit -m "Added greeter class"

h2. Changes for Greet: Modify the main program

p. Update the hello.rb file to use greeter

File: lib/hello.rb
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
EOF

Execute:
git add lib/hello.rb
git commit -m "Hello uses Greeter"

h2. Changes for Greet: Update the Rakefile

p. Update the Rakefile to use an external ruby process

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  ruby '-Ilib', 'lib/hello.rb'
end
EOF

Execute:
git add Rakefile
git commit -m "Updated Rakefile"

h2. Up Next

p. We now have a new branch called *greet* with 3 new commits on it.
Next we will learn how to navigate and switch between branches.

----------------------------------------------------------------------
h1. Navigating Branches

h2. Goals

* Learn how to navigate between the branches of a repository

p. You now have two branches in your project:

Execute:
git hist --all
=log

Output:
=log
EOF

h2. Switch to the Main Branch

p. Just use the @git checkout@ command to switch between branches.

Execute:
git checkout main
=checkout
cat lib/hello.rb
=cat

Output:
=checkout
=cat
EOF

p. You are now on the main branch.  You can tell because the
hello.rb file doesn't use the @Greeter@ class.

h2. Switch Back to the Greet Branch.

Execute:
git checkout greet
=checkout2
cat lib/hello.rb
=cat2

Output:
=checkout2
=cat2
EOF

p. The contents of the @lib/hello.rb@ confirms we are back on the
*greet* branch.

----------------------------------------------------------------------
h1. Changes in Main

h2. Goals

* Learning how to deal with multiple branches with different (and possibly conflicting) changes.

p. While you were changing the greet branch, someone else decided to
update the main branch.  They added a README.

h2. Switch to the main branch.

Execute:
git checkout main

h2. Create the README.

File: README
This is the Hello World example from the git tutorial.
EOF

h2. Commit the README to main.

Execute:
git add README
git commit -m "Added README"

----------------------------------------------------------------------
h1. Viewing Diverging Branches

h2. Goals

* Learn how to view diverging branches in a repository.

h2. View the Current Branches

p. We now have two diverging branches in the repository.  Use the
following log command to view the branches and how they diverge.

Execute:
git hist --all
=log

Output:
=log
EOF

p. Here is our first chance to see the @--graph@ option on @git hist@ in
action. Adding the @--graph@ option to @git log@ causes it to draw the
commit tree using simple ASCII characters.  We can see both branches
(greet and main), and that the main branch is the current HEAD.
The common ancestor to both branches is the "Added a Rakefile" branch.

p. The @--all@ flag makes sure that we see all the branches.  The
default is to show only the current branch.

----------------------------------------------------------------------
h1. Merging

h2. Goals

* Learn how to merge two diverging branches to bring the changes back into a single branch.

h2. Merge the branches

p. Merging brings the changes in two branches together.  Let's go back
to the greet branch and merge main onto greet.

Execute:
git checkout greet
=checkout
git merge main
=merge
git hist --all
=hist

Output:
=checkout
=merge
=hist
EOF

p. By merging main into your greet branch periodically, you can pick
up any changes to main and keep your changes in greet compatible
with changes in the mainline.

p. However, it does produce ugly commit graphs. Later we will look at
the option of rebasing rather than merging.

h2. Up Next

p. But first, what if the changes in main conflict with the changes
in greet?

----------------------------------------------------------------------
h1. Cherry-Picking

h2. Goals

* Learn how to get work from another branch by cherry-picking the commit into your branch.

h2. Switch to a New Branch and Create a New Change

p. Let's make a new branch with a new change.

Execute:
git checkout -b excitement

File: lib/greeter.rb
class Greeter
  def initialize(who, excited = true)
    @who = who
    @excited = excited
  end
  def greet
    "Hello, #{@who}#{punctuation}"
  end
  def punctuation
    @excited ? "!" : "."
  end
end
EOF

Execute:
git add lib/greeter.rb
git commit -m "Add excitement"

h2. Switch Back to the Greeter Branch and Cherry-Pick the Change

p. The cherry-pick operation allows you to copy commits directly onto your
branch. The commits can come from anywhere as long as git knows about their
hash identifier. This is useful when you don't necessarily want all of the work
from a colleague's branch and just want part of it.

p. Execute the following commands using the hash for the commit you just
created. Before doing the cherry-pick you'll confirm that this is indeed the
correct commit by viewing it.

Set: hash=hash_for("Add excitement")
Execute:
git checkout greet
git show <hash>
=show
git cherry-pick <hash>
=cherry

Output:
=show
=cherry
EOF

h2. Up Next

p. Now that you know how to cherry-pick you might wonder how to get work that
isn't already in your git repository. You'll learn how to use patch-apply next.

----------------------------------------------------------------------
h1. Applying Patches

h2. Goals

* Create a patch and apply it manually to the @greet@ branch.

p. A patch is simply a special file that records changes to other files. Git
can create these patches for you to send to other collaborators and it can
apply patches from collaborators to your local repository.

h2. Create the Patch

p. Switch back to the @excited@ branch and add this change.

Execute:
git checkout excitement

File: lib/greeter.rb
  def initialize(who, excited = true, unsure = true)
    @who = who
    @excited = excited
    @unsure = unsure
  end
  def greet
    "Hello, #{@who}#{punctuation}"
  end
  def punctuation
    punct = ""
    if @excited
        punct += "!"
    else
        punct += "."
    end
    if @unsure
        punct += "?"
    end
    punct
  end
end
EOF

p. Now to create the patch all you need to do is show the changes and save the
output.

Execute:
git diff
=diff
git diff > suspicion.patch
=diff2

Output:
=diff
=diff2
EOF

h2. Switch Back to the Greet Branch

p. Switch back to the greet branch, resetting any local changes to the files to
allow applying the patch manually.

Execute:
git checkout -f greet

h2. Apply the Patch

p. Now you can apply the patch using @git apply@. Make sure to also confirm it
applied successfully. The output from @git diff@ should match the output from
above.

Execute:
git apply suspicion.patch
=apply
git diff
=apply2

Output:
=apply
=apply2
EOF

p. Notice that this did not commit the changes. You can commit them as usual.

Execute:
git add lib/greeter.rb
git commit -m "Add some suspicion"

h2. Cleanup

p. You can remove the patch file now that it's been applied.

Execute:
rm suspicion.patch

----------------------------------------------------------------------
h1. Creating a Conflict

h2. Goals

* Create a conflicting change in the main branch.

h2. Switch back to main and create a conflict

p. Switch back to the main branch and make this change:

Execute:
git checkout main

File: lib/hello.rb
puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
EOF

Execute:
git add lib/hello.rb
git commit -m "Made interactive"

h2. View the Branches

Execute:
git hist --all
=log

Output:
=log
EOF

p. Main at commit "Added README" has been merged to the greet
branch, but there is now an additional commit on main that has not
been merged back to greet.

h2. Up Next

p. The latest change in main conflicts with some existing changes in
greet.  Next we will resolve those changes.

----------------------------------------------------------------------
h1. Resolving Conflicts

h2. Goals

* Learn how to handle conflicts during a merge

h2. Merge main to greet

p. Now go back to the greet branch and try to merge the new main.

Execute:
git checkout greet
!git merge main

Output:
$ git checkout greet
Switched to branch 'greet'
$ git merge main
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
Automatic merge failed; fix conflicts and then commit the result.
EOF

If you open lib/hello.rb, you will see:

file: lib/hello.rb
<<<<<<< HEAD
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
=======
# Default is World

puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
>>>>>>> main
EOF

p. The first section is the version on the head of the current branch
(greet).  The second section is the version on the main branch.

h2. Fix the Conflict

p. You need to manually resolve the conflict.  Modify @lib/hello.rb@
to be the following.

File: lib/hello.rb
require 'greeter'

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
EOF

h2. Commit the Conflict Resolution

Execute:
git add lib/hello.rb
=add
git commit -m "Merged main fixed conflict."
=commit

Output:
=add
=commit
EOF

h2. Advanced Merging

p. git doesn't provide any graphical merge tools, but it will gladly
work with any third party merge tool you wish to use.  See
"http://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#External-Merge-and-Diff-Tools":http://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#External-Merge-and-Diff-Tools
for a description of using the Perforce merge tool with git.

----------------------------------------------------------------------
h1. Rebasing VS Merging

h2. Goals

* Learn the differences between rebasing and merging.

h2. Discussion

p. Let's explore the differences between merging and rebasing.  In
order to do so, we need to rewind the repository back in time before
the first merge, and then redo the same steps, but using rebasing
rather than merging.

p. We will make use the of the @reset@ command to wind the branches
back in time.

----------------------------------------------------------------------
h1. Resetting the Greet Branch

h2. Goals

* Reset the greet branch to the point before the first merge.

h2. Reset the greet branch

p. Let's go back in time on the greet branch to the point _before_ we
merged main onto it.  We can *reset* a branch to any commit we want.
Essentially this is modifying the branch pointer to point to anywhere
in the commit tree.

p. In this case we want to back greet up to the point prior to the
merge with main.  We need to find the last commit before the merge.

Execute:
git checkout greet
=checkout
git hist
=log

Output:
=checkout
=log
EOF

p. That's a bit hard to read, but looking at the data we see that the
"Updated Rakefile" commit was the last commit on the greet branch
before merging.  Let's reset the greet branch to that commit.

Set: hash=hash_for("Updated Rakefile")
Execute:
git reset --hard <hash>
=reset

Output:
=reset
EOF

h2. Check the branch.

p. Look at the log for the greet branch.  We no longer have the merge
commits in its history.

Execute:
git hist --all
=log2

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Resetting the Main Branch

h2. Goals

* Reset the main branch to the point before the conflicting commit.

h2. Reset the main branch

p. When we added the interactive mode to the main branch, we made a
change that conflicted with changes in the greet branch. Let's rewind
the main branch to a point before the conflicting change.  This
allows us to demonstrate the rebase command without worrying about
conflicts.

Execute:
git checkout main
git hist
=log

Output:
=log
EOF

p. The 'Added README' commit is the one directly before the
conflicting interactive mode.  We will reset the main branch to
'Added README' commit.

Set: hash=hash_for("Added README")
Execute:
git reset --hard <hash>
git hist --all
=log2

p. Review the log.  It should look like the repository has been wound
back in time to the point before we merged anything.

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Rebasing

h2. Goals

* Use the rebase command rather than the merge command.

p. Ok, we are back in time before the first merge and we want to get
the changes in main into our greet branch.

p. This time we will use the rebase command instead of the merge
command to bring in the changes from the main branch.

Execute:
git checkout greet
git rebase main
git hist
=log

Output:
$ go greet
Switched to branch 'greet'
$
$ git rebase main
First, rewinding head to replay your work on top of it...
Applying: added Greeter class
Applying: hello uses Greeter
Applying: updated Rakefile
$
=log
EOF

h2. Merge VS Rebase

p. The final result of the rebase is very similar to the merge.  The
greet branch now contains all of its changes, as well as all the
changes from the main branch.  However, the commit tree is quite
different.  The commit tree for the greet branch has been rewritten so
that the main branch is a part of the commit history.  This leaves
the chain of commits linear and much easier to read.

h2. When to Rebase, When to Merge?

p. Don't use rebase ...

# If the branch is public and shared with others.  Rewriting publicly shared branches will tend to screw up other members of the team.
# When the _exact_ history of the commit branch is important (since rebase rewrites the commit history).

p. Given the above guidelines, I tend to use rebase for short-lived,
local branches and merge for branches in the public repository.

----------------------------------------------------------------------
h1. Merging Back to Main

h2. Goals

* We've kept our greet branch up to date with main (via rebase), now let's merge the greet changes back into the main branch.

h2. Merge greet into main

Execute:
git checkout main
git merge greet
=merge

Output:
$ git checkout main
Switched to branch 'main'
$
=merge
EOF

p. Because the head of main is a direct ancestor of the head of the
greet branch, git is able to do a fast-forward merge.  When
fast-forwarding, the branch pointer is simply moved forward to point
to the same commit as the greeter branch.

p. There will never be conflicts in a fast-forward merge.

h2. Review the logs

Execute:
git hist
=log

Output:
=log
EOF

p. The greet and main branches are now identical.

----------------------------------------------------------------------
h1. Using Rebase to Modify Old Commits

h2. Goals

p. Suppose you found a change that should be made in an old commit. You can use
@git rebase@ to add that change to the commit seamlessly.

h2. Fix a Bug in the Greeter Class

p. Our greeter class doesn't use proper punctuation when greeting the user.
Let's fix that by adding a period to our greeting line.

File: lib/greeter.rb
class Greeter
  def initialize(who)
    @who = who
  end
  def greet
    "Hello, #{@who}."
  end
end
EOF

Execute:
git add lib/greeter.rb
git commit -m "Add missing punctuation"

p. If we haven't made the greeter class public yet there's no need to keep this
as a separate commit. It would just add noise to the final history. You can use
@git rebase@ to squash this commit into the one that added the greeter class.
First, you'll need to find a rebase starting point. Usually the @main@ branch
is good for this when working on your own branch, but for this exercise we'll
use the commit before the one that added the greeter class.

p. First find the commit that added the greeter class.

Execute:
git hist
=hist1

Output:
=hist1
EOF

p. Then perform the rebase

Set: hash=hash_for("Added greeter class")
Execute:
-git rebase -i <hash>^
+echo -e "/punctuation\\rddggpcefixup\\e:x\\r" > script
+git -c "core.editor=vim -s script" rebase -i <hash>^
+rm script

p. You should see a file open in your editor that looks similar to the example below.

Output:
pick 0b741fa Added greeter class
pick b597367 Hello uses Greeter
pick d1233fa Updated Rakefile
pick dc9d1f3 Add missing punctuation
pick e62cb79 Changed README in original repo
pick 6cac757 Added shared comment to readme

# Rebase 827c6b1..6cac757 onto 827c6b1 (6 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup [-C | -c] <commit> = like "squash" but keep only the previous
#                    commit's log message, unless -C is used, in which case
#                    keep only this commit's message; -c is same as -C but
#                    opens the editor
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified); use -c <commit> to reword the commit message
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
EOF

p. The bottom portion includes some instructions and reminders of the possible
commands. By default, the rebase operation will "pick" each commit and add them
one after the other in the order specified. We will want to use the "fixup"
command. Change the file to match the example below.

Output:
pick 0b741fa Added greeter class
fixup dc9d1f3 Add missing punctuation
pick b597367 Hello uses Greeter
pick d1233fa Updated Rakefile
pick e62cb79 Changed README in original repo
pick 6cac757 Added shared comment to readme

# Rebase 827c6b1..6cac757 onto 827c6b1 (6 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup [-C | -c] <commit> = like "squash" but keep only the previous
#                    commit's log message, unless -C is used, in which case
#                    keep only this commit's message; -c is same as -C but
#                    opens the editor
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified); use -c <commit> to reword the commit message
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
EOF

p. Then save and exit and the rebase will continue as normal. If you look at
the commit adding the greeter class now you will see that it includes the
punctuation change we just added.

Set: hash=hash_for("Added greeter class")
Execute:
git show <hash>
=show

Output:
=show
EOF

h2. Up Next

p. You'll learn how to automate this process with the @--autosquash@ option,
but first you'll learn about the reflog.

----------------------------------------------------------------------
h1. The Reflog

h2. Goals

* Learn what the reflog is and how to use it.

p. The reference log (or "reflog") is useful to find the exact commit you were on
at some time in the past. It comes in handy when trying to do undo things like
complicated merges or rebases that might have gone wrong.

h2. View the Reflog

Execute:
git reflog
=reflog

p. Each line in the output starts with a commit hash and has a reference of the
form <code>HEAD@{1}</code>, followed by a description of how you got there and
what the commit message was. You can enter that @HEAD@ value anywhere a hash
would be used and go back in time to that exact point.

Output:
=reflog
EOF

h2. Go Back in Time

p. The next lab is going to repeat the steps of the previous lab but automate
it. For that to work you will need to reset your working directory back to
before the previous rebase. Use the reflog to find the line with the content
@commit: Add missing punctuation@. Note the @HEAD@ reference. Now perform the
@git reset@ and confirm the status of the working directory and the log history.

Execute:
git reset --hard HEAD@{5}
=reflog2
git status
=reflog3
git hist
=reflog4

Output:
=reflog2
=reflog3
=reflog4
EOF

h2. Next Up

p. Next you'll learn about the @--autosquash@ option and how to automate simple
rebase tasks.

----------------------------------------------------------------------
h1. Rebasing Automatically

h2. Goals

* Use @git rebase --autosquash@ to automatically fix up old commits.

h2. Getting Ready

p. The rebase tool follows certain conventions regarding commit messages that
allow it to work automatically for simple situations. If a commit message
starts with "squash!", "fixup!" or "amend!" and follows with a target commit
hash or the first line of the target commit message, then that commit will be
merged into the target commit using the specified action on a rebase. To start
this lab we must first undo the latest commit.

Execute:
git reset HEAD^

h2. Making the Commit

p. Next we will recommit the changes using a new option to the @git commit@
command. You will want to find the commit hash for the "Added greeter class"
commit to do this step.

Set: hash=hash_for("Added greeter class")
Execute:
git add lib/greeter.rb
git commit --fixup=<hash>
git show
=commit

p. The resulting commit should appear similar to the below example.

Output:
=commit
EOF

h2. Rebasing

p. Now you can use git rebase to automatically update the old commit. As in the
previous rebase exercise we will rebase using the commit before our target
commit as the rebase point.

Set: hash=hash_for("[a-f0-9]+ Added greeter class")
Execute:
-git rebase -i --autosquash <hash>^
+git -c core.editor=cat rebase -i --autosquash <hash>^
git log --oneline
=hist

Output:
=hist
EOF

----------------------------------------------------------------------
h1. Multiple Repositories

p. Up to this point we have been working with a single git repository.
However, git excels at working with multiple repositories.  These
extra repositories may be stored locally, or may be accessed across a
network connection.

p. In the next section we will create a new repository called
"cloned_hello".  We will show how to move changes from one repository
to another, and how to handle conflicts when they arise between
two repositories.

 !git_clone.png!


p. For now, we will be working with local repositories
(i.e. repositories stored on your local hard disk), however most of
the things learned in this section will apply to multiple repositories
whether they are stored locally or remotely over a network.

p. *NOTE:* We are going be making changes to both copies of our
repositories.  Make sure you pay attention to which repository you are
in at each step of the following labs.

----------------------------------------------------------------------
h1. Cloning Repositories

h2. Goals

* Learn how to make copies of repositories.

h2. Go to the work directory

p. Go to the working directory and make a clone of your hello
repository.

Execute:
cd ..
=cd
pwd
=pwd
ls
=ls

p{color:red}. *NOTE: Now in the work directory.*

Output:
=cd
=pwd
=ls
EOF

p. At this point you should be in your "work" directory.  There should
be a single repository here named "hello".

h2. Create a clone of the hello repository

p. Let's make a clone of the repository.

Execute:
git clone hello cloned_hello
=clone
ls
=ls2
+cd cloned_hello
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"
+cd ..

Output:
=clone
=ls2
EOF

p. There should now be two repositories in your work directory: the
original "hello" repository and the newly cloned "cloned_hello"
repository.

----------------------------------------------------------------------
h1. Review the Cloned Repository

h2. Goals

* Learn about branches on remote repositories.

h2. Look at the cloned repository

p. Let's take a look at the cloned repository.

Execute:
cd cloned_hello
=cd
ls
=ls

Output:
=cd
=ls
EOF

p. You should see a list of all the files in the top level of the
original repository (@README@, @Rakefile@ and @lib@).


h2. Review the Repository History

Execute:
git hist --all
=log

Output:
=log
EOF

p. You should now see a list of all the commits in the new
repository, and it should (more or less) match the history of commits
in the original repository.  The only difference should be in the
names of the branches.

h2. Remote branches

p. You should see a *main* branch (along with *HEAD*) in the history
list.  But you will also have a number of strangely named branches
(*origin/main*, *origin/greet* and *origin/HEAD*).  We'll talk about
them in a bit.

----------------------------------------------------------------------
h1. What is Origin?

h2. Goals

* Learn about naming remote repositories.

Execute:
git remote
=remote

Output:
=remote
EOF

p. We see that the cloned repository knows about a remote repository
named origin.  Let's see if we can get more information about origin:

Execute:
git remote show origin
=show

Output:
=show
EOF

p. Now we see that the remote repository "origin" is simply the original
*hello* repository.  Remote repositories typically live on a separate
machine, possibly a centralized server.  As we can see here, however,
they can just as well point to a repository on the same machine.
There is nothing particularly special about the name "origin",
however the convention is to use the name "origin" for
the primary centralized repository (if there is one).

----------------------------------------------------------------------
h1. Remote Branches

h2. Goals

* Learn about local VS remote branches

p. Let's look at the branches available in our cloned repository.

Execute:
git branch
=branch

Output:
=branch
EOF

p. That's it, only the main branch is listed.  Where is the greet
branch?  The *git* *branch* command only lists the local branches by
default.

h2. List Remote Branches

p. Try this to see all the branches:

Execute:
git branch -a
=branch_a

Output:
=branch_a
EOF

p. Git has all the commits from the original repository, but branches
in the remote repository are not treated as local branches here.  If
we want our own *greet* branch, we need to create it ourselves. We
will see how to do that in a minute.

----------------------------------------------------------------------
h1. Change the Original Repository

h2. Goals

* Make some changes to the original repository so we can try to pull the changes

h2. Make a change in the original *hello* repository

Execute:
cd ../hello
+pwd
# (You should be in the original hello repository now)

p{color:red}. *NOTE: Now in the _hello_ repo*

p. Make the following changes to README:

File: README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. Now add and commit this change

Execute:
git add README
git commit -m "Changed README in original repo"

h2. Up Next

p. The original repository now has later changes that are not in the
cloned version.  Next we will pull those changes across to the cloned
repository.

----------------------------------------------------------------------
h1. Fetching Changes

h2. Goals

* Learn how to pull changes from a remote repository.

Execute:
cd ../cloned_hello
+pwd
git fetch
=fetch
git hist --all
=hist

p(note red). *NOTE: Now in the _cloned_hello_ repo*

Output:
=fetch
=hist
EOF

p. At this point the repository has all the commits from the original
repository, but they are not integrated into the cloned
repository's local branches.

p. Find the "Changed README in original repo" commit in the history
above.  Notice that the commit includes "origin/main" and
"origin/HEAD".

p. Now look at the "Updated Rakefile" commit.  You will see that
the local main branch points to this commit, not to the new commit
that we just fetched.

p. The upshot of this is that the "git fetch" command will fetch new
commits from the remote repository, but it will not merge these
commits into the local branches.

h2. Check the README

We can demonstrate that the cloned README is unchanged.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
EOF

p. See, no changes.

----------------------------------------------------------------------
h1. Merging Pulled Changes

h2. Goals

* Learn to get the pulled changes into the current branch and working directory.

h2. Merge the fetched changes into local main

Execute:
git merge origin/main
=merge

Output:
=merge
EOF

h2. Check the README again

p. We should see the changes now.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. There are the changes.  Even though "git fetch" does not merge the
changes, we can still manually merge the changes from the remote
repository.

h2. Up Next

p. Next let's take a look at combining the fetch & merge process into
a single command.

----------------------------------------------------------------------
h1. Pulling Changes

h2. Goals

* Learn that @git pull@ is equivalent to a @git fetch@ followed by a @git merge@.

h2. Discussion

p. We're not going to go through the process of creating another
change and pulling it again, but we do want you to know that doing:

pre(instructions). git pull

is indeed equivalent to the two steps:

pre(instructions). git fetch
git merge origin/main

----------------------------------------------------------------------
h1. Adding a Tracking Branch

h2. Goals

* Learn how to add a local branch that tracks a remote branch.

p. The branches starting with remotes/origin are branches from the
original repo.  Notice that you don't have a branch called greet
anymore, but it knows that the original repo had a greet branch.

h2. Add a local branch that tracks a remote branch.

Execute:
git branch --track greet origin/greet
=branch_track
git branch -a
=branch_a
git hist --max-count=2
=log

Output:
=branch_track
=branch_a
=log
EOF

p. We can now see the greet branch in the branch list and in the log.

----------------------------------------------------------------------
h1. Bare Repositories

h2. Goals

* Learn how to create bare repositories.

p. Bare repositories (without working directories) are usually used for
sharing.

h2. Create a bare repository.

Execute:
cd ..
+pwd
git clone --bare hello hello.git
=clone
ls hello.git
=ls

p{color:red}. *NOTE: Now in the work directory*

Output:
=clone
=ls
EOF

p. The convention is that repositories ending in '.git' are bare
repositories.  We can see that there is no working directory in the
hello.git repo.  Essentially it is nothing but the .git directory of a
non-bare repo.

----------------------------------------------------------------------
h1. Adding a Remote Repository

h2. Goals

* Add the bare repository as a remote to our original repository.

p. Let's add the hello.git repo to our original repo.

Execute:
cd hello
+pwd
git remote add shared ../hello.git

p{color:red}. *NOTE: Now in the +hello+ repository.*

----------------------------------------------------------------------
h1. Pushing a Change

h2. Goals

* Learn how to push a change to a remote repository.

p. Since bare repositories are usually shared on some sort of network
server, it is usually difficult to cd into the repo and pull changes.
So we need to push our changes into other repositories.

p. Let's start by creating a change to be pushed.  Edit the README and
commit it

File: README
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
EOF

Execute:
git checkout main
git add README
git commit -m "Added shared comment to readme"

p. Now push the change to the shared repo.

Execute:
git push shared main
=push

p. _shared_ is the name of the repository receiving the changes we are
pushing. (Remember, we added it as a remote in the previous lab.)

Output:
=push
EOF

p(note). *NOTE:* We had to explicitly name the branch main that was
receiving the push.  It is possible to set it up automatically, but I
_never_ remember the commands to do that.  Check out the "Git Remote
Branch" gem for easy management of remote branches.

----------------------------------------------------------------------
h1. Pulling Shared Changes

h2. Goals

* Learn how to pull changes from a shared repository.

p. Quick hop over to the clone repository and let's pull down the
changes just pushed to the shared repo.

Execute:
cd ../cloned_hello
+pwd

p{color:red}. *NOTE: Now in the _cloned_hello_ repo.*

p. Continue with...

Execute:
git remote add shared ../hello.git
git branch --track shared main
git pull shared main
cat README

----------------------------------------------------------------------
h1. Advanced / Future Topics

p. Here are some topics you might want to research on your own:

* Hosting your git repository
* Protocols
* SSH Setup
* Remote Branch Management
* Finding Buggy Commits (git bisect)
* Workflows
* Non-command line tools (gitx, gitk, magit)
* Working with GitHub

----------------------------------------------------------------------
h1. Thank You

p. Thank you for trying out the Git Immersion Labs.  Feel free to send
comments to ops@mojotech.com

----------------------------------------------------------------------
